# Production Service Specification

## Обзор

Production Service — это микросервис для управления производственными рецептами и заданиями в игре Shard Legends: Clan Wars. Сервис обеспечивает выполнение всех видов производственных процессов: от получения сундуков из мини-игры "Дека" до крафта инструментов в кузнице, включая управление фабрикой, очередями заданий и системой модификаторов.

## Технические характеристики

- **Язык**: Golang
- **Порт**: 8080 (внутренний)
- **База данных**: PostgreSQL 17 (схема `production`)
- **Кеширование**: Redis 8.0.2
- **Аутентификация**: JWT токены через Auth Service (валидация по RS256 подписи + проверка отзыва в Redis)
- **API**: RESTful JSON API
- **Документация**: OpenAPI 3.0

## JWT Аутентификация

### Процесс валидации JWT токенов

Все публичные и административные эндпоинты требуют валидного JWT токена в заголовке `Authorization: Bearer <token>`.

**Последовательность проверки токена:**

1. **Проверка формата токена**
   - Извлечение токена из заголовка `Authorization`
   - Проверка префикса `Bearer `
   - Парсинг JWT структуры

2. **Валидация подписи JWT**
   - Получение публичного ключа RSA от Auth Service (`GET http://auth-service:8080/public-key.pem`)
   - Проверка RS256 подписи токена
   - Валидация алгоритма подписи

3. **Проверка времени действия**
   - Автоматическая проверка `exp` claim в JWT
   - Отклонение просроченных токенов

4. **Проверка отзыва токена**
   - Извлечение `jti` (JWT ID) из токена
   - Проверка в Redis: `EXISTS revoked:{jti}`
   - Отклонение отозванных токенов

5. **Извлечение данных пользователя**
   - Получение `user_id` из claim `sub`
   - Получение `telegram_id` из claim `telegram_id`
   - Сохранение в контексте запроса

**Структура JWT токена:**
```json
{
  "iss": "shard-legends-auth",
  "sub": "uuid-internal-user-id",
  "telegram_id": 123456789,
  "iat": 1703243400,
  "exp": 1703329800,
  "jti": "uuid-token-id"
}
```

**Возможные ошибки аутентификации:**
- `missing_token` (401) - Отсутствует заголовок Authorization
- `invalid_token_format` (401) - Неправильный формат Bearer токена
- `invalid_token_signature` (401) - Неверная подпись JWT
- `invalid_token_claims` (401) - Некорректные claims в токене
- `missing_token_id` (401) - Отсутствует JTI в токене
- `token_revoked` (401) - Токен отозван
- `missing_user_id` (401) - Отсутствует user_id в токене

**Зависимости:**
- Auth Service для получения публичного ключа
- Redis для проверки отозванных токенов
- JWT библиотека для парсинга и валидации

## API Endpoints

### Публичные эндпоинты (для фронтенда)

#### Получение рецептов
```
GET /recipes
```

**Описание:** Возвращает список активных производственных рецептов для пользователя

**Входные параметры:**
- Класс операции (опционально)
- ID пользователя (из JWT токена)

**Аутентификация**: Требует валидный JWT токен в заголовке `Authorization: Bearer <token>`

**Выходные данные:**
- Список рецептов с соответствующими лимитами для пользователя

#### Получение очереди производства
```
GET /factory/queue
```

**Описание:** Возвращает текущую очередь производственных заданий пользователя

**Выходные данные:**
- Список заданий со статусами и временем завершения
- Информация о доступных слотах

#### Получение завершенных заданий
```
GET /factory/completed
```

**Описание:** Возвращает список завершенных заданий, готовых к Claim

**Выходные данные:**
- Список заданий в статусе "completed" с результатами

#### Запуск производства
```
POST /factory/start
```

**Описание:** Создает новое производственное задание и добавляет его в очередь

**Входные параметры:**
- ID рецепта
- Количество исполнений
- Ускорители (опционально) - предметы-модификаторы из инвентаря пользователя

**Действия при вызове:**
1. Проверка доступности рецепта и лимитов
2. Применение модификаторов в порядке приоритета:
   - Автоматические модификаторы от характеристик персонажа (VIP, уровень, достижения, клан)
   - Событийные модификаторы (TBD - будет добавлено после реализации Event Service)
   - Ускорители-предметы (переданные пользователем)
3. **Расчет итоговых требований к входным предметам** с учетом модификаторов снижения затрат
4. **Предрасчет результата** - окончательное определение выходных предметов с учетом:
   - Случайного выбора по вероятностям из рецепта
   - Количества в диапазоне (min_quantity - max_quantity)
   - Наследования коллекций и качества от входных предметов
   - Примененных модификаторов (бонусы к количеству, вероятности)

**АТОМАРНАЯ ОПЕРАЦИЯ (выполняется в единой транзакции):**

5. **Создание задания с зафиксированным результатом** - запись в базу данных Production Service
6. **Резервирование всех требуемых предметов** через `POST /inventory/reserve` с параметрами:
   - `user_id`: из JWT токена
   - `operation_id`: UUID созданного задания  
   - `items`: массив включающий входные предметы (с учетом модификаторов) + ускорители
7. **При ошибке резервирования любого предмета:**
   - Откат транзакции создания задания в Production Service
   - Отмена всех успешно зарезервированных предметов через `POST /inventory/return-reserve`
   - Возврат ошибки пользователю с деталями о недостающих предметах

**Критически важно:** Пункты 5-7 должны выполняться как единая атомарная операция для предотвращения рассинхронизации данных между сервисами. Если резервирование не удалось, задание не должно быть создано.

8. **При успешном резервировании:** постановка в очередь или немедленный запуск

**Выходные данные:**
- ID созданного задания
- Статус задания и ожидаемое время завершения

#### Claim результатов
```
POST /factory/claim
```

**Описание:** Получает результаты завершенного производственного задания

**Входные параметры:**
- ID задания или "all" для всех готовых

**Действия при вызове:**
1. Проверка статуса задания (completed)
2. Уничтожение зарезервированных материалов через `POST /inventory/consume-reserve` (внутренний эндпоинт)
3. Добавление результатов в инвентарь через `POST /inventory/add-items` (внутренний эндпоинт) с параметрами:
   - `user_id`: из JWT токена
   - `section`: "main"
   - `operation_type`: "craft_result"
   - `operation_id`: UUID задания
   - `items`: результаты производства
4. Обновление статуса задания на "claimed"
5. Освобождение слота для следующего задания

**Выходные данные:**
- Список полученных предметов
- Обновленное состояние очереди

#### Отмена задания
```
POST /factory/cancel
```

**Описание:** Отменяет задание в статусе "pending" с возвратом материалов

### Внутренние эндпоинты (для других сервисов)

#### Получение слотов пользователя
```
GET /internal/user-slots/{user_id}
```

**Описание:** Возвращает информацию о доступных производственных слотах (для User Service)

### Административные эндпоинты

#### Мониторинг заданий
```
GET /admin/tasks
```

**Описание:** Возвращает статистику и мониторинг производственных заданий

**Входные параметры:**
- Фильтрация по пользователю, статусу, временному периоду
- Пагинация для больших списков

**Выходные данные:**
- Агрегированная статистика по производственным процессам
- Общая информация о загрузке системы

## Модель данных

### Основные сущности

#### Производственный рецепт (Production Recipe)
- `id` - UUID рецепта
- `name` - уникальное название рецепта
- `operation_class_id` - ссылка на элемент классификатора `production_operation_classes` для определения слота
- `description` - текстовое описание процесса
- `is_active` - доступен ли рецепт для использования
- `production_time_seconds` - базовая длительность выполнения рецепта
- `created_at` / `updated_at` - временные метки

#### Входные предметы рецепта (Recipe Input Items)
- `recipe_id` - ссылка на рецепт
- `item_id` - UUID предмета из `inventory.items`
- `collection_code` - код коллекции из классификатора (опционально, null для стандартной)
- `quality_level_code` - код уровня качества из классификатора (опционально, null для стандартного)
- `quantity` - требуемое количество предмета

#### Выходные предметы рецепта (Recipe Output Items)
- `recipe_id` - ссылка на рецепт
- `item_id` - UUID создаваемого предмета из `inventory.items`
- `min_quantity` - наименьшее количество при выпадении
- `max_quantity` - наибольшее количество при выпадении
- `probability_percent` - шанс получения этого предмета (в процентах)
- `output_group` - принадлежность к группе взаимоисключающих предметов (опционально)
- `collection_source_input_index` - индекс входного предмета для наследования коллекции (null если не наследуется)
- `quality_source_input_index` - индекс входного предмета для наследования качества (null если не наследуется)
- `fixed_collection_code` - явно указанная коллекция (альтернатива наследованию)
- `fixed_quality_level_code` - явно указанное качество (альтернатива наследованию)

#### Лимиты рецептов (Recipe Limits)
- `recipe_id` - ссылка на рецепт
- `limit_type_id` - ссылка на элемент классификатора `recipe_limit_types` (всего, в день, в неделю, в месяц, в сезон, за событие)
- `limit_object_id` - ссылка на элемент классификатора `recipe_limit_objects` (запуск рецепта или получение конкретного предмета)
- `target_item_id` - конкретный предмет (для лимитов на получение)
- `limit_quantity` - максимальное количество использований

#### Производственное задание (Production Task)
- `id` - UUID задания (используется как operation_id для резервирования в Inventory Service)
- `user_id` - UUID пользователя
- `recipe_id` - ссылка на исходный производственный рецепт
- `operation_class_id` - класс операции для определения слота
- `status` - текущее состояние (pending, in_progress, completed, claimed, cancelled, failed)
- `production_time_seconds` - итоговое время выполнения с учетом модификаторов
- `created_at` - когда задание было создано
- `started_at` - когда начался процесс (если запущено)
- `completed_at` - расчетное время завершения
- `applied_modifiers` - JSON список примененных автоматических модификаторов от характеристик персонажа для аудита

#### Выходные предметы задания (Task Output Items)
- `task_id` - ссылка на задание
- `item_id` - ссылка на полученный предмет
- `collection_id` - коллекция предмета
- `quality_level_id` - уровень качества
- `quantity` - фактическое количество (предрасчитано при создании задания)

### Проверка лимитов

**Принцип динамической проверки:** Вместо отдельной таблицы учета лимитов используется динамическая проверка по истории производственных заданий.

**Алгоритм проверки лимитов:**
1. **Определение периода** - на основе типа лимита (день/неделя/месяц/сезон/событие)
2. **Подсчет использований** - запрос к таблице `production_tasks` за указанный период
3. **Сравнение с лимитом** - проверка превышения максимального количества

**Примеры SQL запросов для проверки:**
```sql
-- Дневной лимит на рецепт
SELECT COUNT(*) FROM production_tasks 
WHERE user_id = $1 AND recipe_id = $2 
  AND created_at >= date_trunc('day', now())
  AND status != 'cancelled';

-- Лимит на получение конкретного предмета за событие
SELECT SUM(toi.quantity) 
FROM production_tasks pt
JOIN task_output_items toi ON pt.id = toi.task_id
WHERE pt.user_id = $1 AND toi.item_id = $2
  AND pt.created_at >= $event_start_date
  AND pt.status IN ('completed', 'claimed');
```

**Требования к индексам для производительности:**
```sql
-- Индекс для проверки лимитов по пользователю и рецепту
CREATE INDEX idx_production_tasks_user_recipe_created 
ON production_tasks(user_id, recipe_id, created_at);

-- Индекс для проверки лимитов по предметам
CREATE INDEX idx_task_output_items_user_item 
ON task_output_items(task_id) 
INCLUDE (item_id, quantity);

-- Композитный индекс для временных фильтров
CREATE INDEX idx_production_tasks_user_status_created 
ON production_tasks(user_id, status, created_at);
```

## Бизнес-логика

### Производственные рецепты

Производственные рецепты определяют все способы создания, получения и преобразования предметов в игре. Рецепты являются статической конфигурацией и определяют только базовые параметры.

**Основная структура рецепта:**
- **Входные предметы** - могут отсутствовать или состоять из нескольких предметов
- **Выходные предметы** - организованы в группы с вероятностями
- **Модификации коллекций** - правила передачи коллекций от входных к выходным
- **Лимиты** - ограничения по времени и количеству использований

**Примеры рецептов:**
- **Получение сундуков**: вход - ничего, выход - сундуки, лимит 10/день
- **Открытие сундуков**: вход - сундук + ключ, выход - ресурсы/реагенты
- **Переплавка**: вход - 100 сырья + 4 реагента, выход - 1 заготовка, время 1 час
- **Крафт инструментов**: вход - чертеж + 4 заготовки, время 12 часов

### Система фабрики и производственных заданий

Фабрика отвечает за исполнение производственных рецептов в контексте конкретного пользователя.

#### Обработка заказа на производство
1. **Валидация доступности** - проверка материалов в инвентаре
2. **Применение модификаторов** - в порядке приоритета:
   - Ускорители (переданные предметы)
   - Пользовательские (VIP, уровень, достижения)
   - Событийные (сезонные, временные акции)
3. **Предрасчет результата** - окончательное определение выходных предметов
4. **Создание задания** - с зафиксированным результатом

### Система производственных слотов

Производственные слоты определяют количество одновременно выполняемых заданий.

**Классы операций:**
- `crafting` - крафт инструментов
- `smelting` - переплавка сырья
- `chest_opening` - открытие сундуков
- `resource_gathering` - добыча на месторождениях
- `special` - уникальные процессы

**Принципы работы:**
- **Единая очередь** - все задания в одной очереди FIFO
- **Автоматическое распределение** - при освобождении слота
- **Возможность ожидания** - задания могут ждать подходящих слотов

### Управление очередью производства

#### Добавление в очередь
1. **Валидация ресурсов** - проверка материалов через Inventory Service
2. **Предрасчет результата** - с учетом модификаторов
3. **Атомарное резервирование** - через Inventory Service
4. **Постановка в хвост** - все новые задания в конец очереди
5. **Проверка слотов** - немедленный запуск или ожидание

#### Алгоритм выделения слота
1. **Определение типа** - какие классы операций поддерживает
2. **Поиск в очереди** - последовательный просмотр pending заданий
3. **Проверка совместимости** - сравнение класса операции
4. **Запуск первого подходящего** - перевод в "in_progress"

### Система модификаторов

#### Типы модификаторов

**1. Модификаторы ускорителей:**
- Ускорение производства (сокращение времени)
- Увеличение количества (модификация диапазонов)
- Повышение шансов (улучшение вероятностей)
- Снижение затрат (уменьшение материалов)

**2. Пользовательские модификаторы:**
- VIP статус (процентные бонусы)
- Уровень персонажа (градуальные улучшения)
- Достижения (постоянные бонусы)
- Клановые бонусы

**3. Событийные модификаторы (TBD - будет реализовано в следующих версиях):**
- Сезонные бонусы
- Лунные циклы ("5% в полнолуние")
- Специальные события
- Серверные буферы

### Алгоритм предрасчета результатов производства

**Критически важно:** Результат производства определяется **в момент создания задания**, а не в момент его завершения. Это обеспечивает:
- **Предсказуемость** - модификаторы и случайность фиксируются при создании
- **Справедливость** - результат не зависит от изменений баланса во время производства
- **Прозрачность** - пользователь может видеть что получится (после Claim)

#### Детальный алгоритм предрасчета

**Выполняется при создании задания (POST /factory/start):**

1. **Сбор всех модификаторов** в порядке приоритета:
   - Ускорители из переданных предметов
   - Пользовательские модификаторы (VIP, уровень, достижения, клан)
   - Событийные модификаторы (TBD - планируется интеграция с Event Service)

2. **Применение модификаторов к рецепту:**
   ```
   Итоговое время = Базовое время × (1 - Σ speed_bonuses)
   Итоговые вероятности = Базовые вероятности × (1 + Σ probability_bonuses)
   Итоговые количества = [min, max] × (1 + Σ quantity_bonuses)
   ```

3. **Обработка выходных групп** согласно бизнес-правилам:
   
   **Альтернативные группы** (взаимоисключающие):
   - Генерация random(0, 1) для группы
   - Выбор предмета по накопленным вероятностям
   - Если сумма вероятностей < 100% - возможен пустой результат
   
   **Индивидуальные предметы** (без группы):
   - Отдельная проверка вероятности для каждого предмета
   - Независимые шансы выпадения

4. **Определение количества для выбранных предметов:**
   ```
   final_quantity = random(modified_min_quantity, modified_max_quantity)
   ```

5. **Обработка наследования коллекций и качества:**
   
   **Наследование от входных предметов:**
   - По индексу входного предмета (`collection_source_input_index`)
   - Передача коллекции/качества от материала к результату
   
   **Фиксированные значения:**
   - Использование `fixed_collection_code` / `fixed_quality_level_code`
   - Явное указание коллекции (например, "CURRENT_SEASON")
   
   **Базовые значения:**
   - Если ничего не указано - стандартная коллекция/качество предмета

6. **Сохранение окончательного результата:**
   - Запись в `task_output_items` с конкретными предметами и количествами
   - Фиксация примененных модификаторов в `applied_modifiers` (JSON)
   - Результат больше не изменяется до момента Claim

#### Примеры предрасчета

**Пример 1: Открытие сундука**
```json
{
  "recipe_outputs": [
    {"item": "wood", "probability": 60, "min_qty": 5, "max_qty": 15, "group": "main"},
    {"item": "stone", "probability": 30, "min_qty": 3, "max_qty": 10, "group": "main"},
    {"item": "gem", "probability": 10, "min_qty": 1, "max_qty": 3, "group": "main"}
  ],
  "modifiers": {"vip_bonus": 0.2, "event_bonus": 0.1},
  "calculated_result": {
    "random_roll": 0.45,
    "selected_item": "wood",
    "final_quantity": 12
  }
}
```

**Пример 2: Крафт инструмента с наследованием**
```json
{
  "input_blueprint": {"collection": "winter_2025", "quality": "rare"},
  "recipe_output": {
    "item": "axe",
    "collection_source_input_index": 0,
    "quality_source_input_index": 0
  },
  "calculated_result": {
    "item": "axe",
    "inherited_collection": "winter_2025",
    "inherited_quality": "rare",
    "quantity": 1
  }
}
```

### Система Claim результатов

После завершения задания результат не попадает в инвентарь автоматически.

#### Процесс Claim
1. **Просмотр результатов** - пользователь видит предрасчитанные результаты
2. **Выполнение Claim** - подтверждение получения
3. **Атомарное зачисление** - через Inventory Service

#### Особенности
- **Скрытность до Claim** - результат неизвестен пользователю до выполнения Claim
- **Обязательность** - без Claim предметы остаются "подвешенными"
- **Отсутствие лимитов** - Claim можно выполнить в любое время
- **Пакетность** - можно забрать все готовые результаты
- **Неизменность** - результат зафиксирован при создании задания
- **Аудит** - все Claim операции логируются

## Управление производственными рецептами

### Принципы управления рецептами

Производственные рецепты управляются **исключительно через систему миграций базы данных**, а не через API эндпоинты. Это обеспечивает:
- **Версионирование** - все изменения рецептов отслеживаются в системе контроля версий
- **Консистентность** - одинаковые рецепты во всех окружениях (dev, staging, production)
- **Безопасность** - исключает случайные изменения рецептов через API
- **Аудит** - полная история изменений конфигурации производства

### Структура миграций рецептов

**Файлы миграций располагаются в:**
```
migrations/
├── production-service/
│   ├── 001_create_production_schema.up.sql
│   ├── 001_create_production_schema.down.sql
│   ├── 002_populate_base_recipes.up.sql
│   ├── 002_populate_base_recipes.down.sql
│   ├── 003_add_winter_event_recipes.up.sql
│   ├── 003_add_winter_event_recipes.down.sql
│   └── ...
```

### Примеры миграций

#### Создание базовых рецептов (002_populate_base_recipes.up.sql)
```sql
-- Вставка базовых производственных рецептов
INSERT INTO production.recipes (id, name, operation_class_code, description, is_active, production_time_seconds) VALUES
('550e8400-e29b-41d4-a716-446655440001', 'chest_opening_basic', 'chest_opening', 'Открытие обычного сундука', true, 5),
('550e8400-e29b-41d4-a716-446655440002', 'smelting_iron_ingot', 'smelting', 'Переплавка железной руды', true, 3600),
('550e8400-e29b-41d4-a716-446655440003', 'crafting_wooden_axe', 'crafting', 'Создание деревянного топора', true, 43200);

-- Входные предметы для рецептов
INSERT INTO production.recipe_inputs (recipe_id, item_id, collection_code, quality_level_code, quantity) VALUES
('550e8400-e29b-41d4-a716-446655440001', 'chest_basic_uuid', null, null, 1),
('550e8400-e29b-41d4-a716-446655440001', 'key_small_uuid', null, 'small', 1);

-- Выходные предметы и их вероятности
INSERT INTO production.recipe_outputs (recipe_id, item_id, min_quantity, max_quantity, probability_percent, output_group) VALUES
('550e8400-e29b-41d4-a716-446655440001', 'wood_uuid', 5, 15, 60, 'main_resources'),
('550e8400-e29b-41d4-a716-446655440001', 'stone_uuid', 3, 10, 30, 'main_resources'),
('550e8400-e29b-41d4-a716-446655440001', 'rare_gem_uuid', 1, 3, 10, 'main_resources');
```

#### Добавление событийных рецептов (003_add_winter_event_recipes.up.sql)
```sql
-- Добавление рецептов для зимнего события
INSERT INTO production.recipes (id, name, operation_class_code, description, is_active, production_time_seconds) VALUES
('550e8400-e29b-41d4-a716-446655440100', 'winter_gift_crafting', 'special', 'Создание зимнего подарка', true, 7200);

-- Лимиты для событийных рецептов
INSERT INTO production.recipe_limits (recipe_id, limit_type, limit_object, limit_quantity) VALUES
('550e8400-e29b-41d4-a716-446655440100', 'per_event', 'recipe_execution', 5);
```

#### Отключение рецептов (004_disable_outdated_recipes.up.sql)
```sql
-- Отключение устаревших рецептов (не удаляем для сохранения истории)
UPDATE production.recipes 
SET is_active = false, updated_at = now()
WHERE name IN ('old_recipe_1', 'deprecated_recipe_2');
```

### Процесс обновления рецептов

#### Разработка
1. **Создание миграции** - разработчик создает новую миграцию с изменениями рецептов
2. **Локальное тестирование** - проверка работы новых рецептов в dev окружении
3. **Code Review** - обязательный ревью изменений команды дизайна/баланса
4. **Commit в Git** - сохранение изменений в системе контроля версий

#### Развертывание
1. **Staging окружение** - автоматическое применение миграций в тестовой среде
2. **QA тестирование** - проверка игровой логики и баланса
3. **Production deployment** - применение миграций в продуктивной среде
4. **Мониторинг** - отслеживание использования новых рецептов

### Особенности управления рецептами

#### Версионирование
- **Никогда не удаляем рецепты** - только отключаем через `is_active = false`
- **Сохраняем историю** - для возможности анализа прошлых конфигураций
- **Фиксированные UUID** - для стабильности ссылок между таблицами

#### Балансировка
- **Постепенные изменения** - небольшие корректировки через отдельные миграции
- **A/B тестирование** - возможность создания альтернативных рецептов для тестирования
- **Откат изменений** - через down миграции при необходимости

#### Безопасность
- **Отсутствие API** - невозможность случайного изменения рецептов через веб-интерфейс
- **Обязательный ревью** - все изменения проходят через систему ревью кода
- **Аудит изменений** - полная история в Git commits

## Производительность и кэширование

Redis используется для кэширования временных данных задач и слотов. Оптимизация производительности достигается за счет баланса между прямым доступом к данным в PostgreSQL и кэшированием в Redis.

### Кэширование рецептов
- **Активные рецепты** кэшируются в Redis на 24 часа
- **Кэш обновляется** автоматически при применении миграций
- **Лимиты пользователей** кэшируются на 1 час для быстрой проверки

## Безопасность

Все входные данные проходят строгую валидацию. Метрики мониторинга и алертов обеспечивают надзор за состоянием сервиса и его компонентов.

## Зависимости

- **Auth Service**: для JWT аутентификации и авторизации
- **Inventory Service**: для обработки и резервирования необходимых для производства предметов

## Требования к доработке смежных сервисов

### User Service (реализуется)

**Требуемые внутренние эндпоинты:**

#### Получение производственных слотов пользователя
```
GET /internal/users/{user_id}/production-slots
```

**Описание:** Возвращает информацию о доступных производственных слотах пользователя

**Выходные данные:**
```json
{
  "user_id": "uuid",
  "total_slots": 2,
  "slots": [
    {
      "slot_type": "universal",
      "supported_operations": ["crafting", "smelting", "chest_opening"],
      "count": 2
    }
  ]
}
```

**Статус реализации:** ✅ Реализовано в User Service (временная версия)
- Возвращает фиксированное значение: 2 универсальных слота
- Поддерживает основные операции: crafting, smelting, chest_opening

**Обоснование:** Production Service должен знать какие слоты доступны пользователю для корректного распределения заданий по очередям.

#### Получение модификаторов пользователя
```
GET /internal/users/{user_id}/production-modifiers
```

**Описание:** Возвращает пользовательские модификаторы для производства

**Выходные данные:**
```json
{
  "user_id": "uuid",
  "modifiers": {
    "vip_status": {
      "level": "none",
      "production_speed_bonus": 0.0,
      "quality_bonus": 0.0
    },
    "character_level": {
      "level": 1,
      "crafting_bonus": 0.0
    },
    "achievements": [],
    "clan_bonuses": {
      "production_speed": 0.0
    }
  }
}
```

**Статус реализации:** ✅ Реализовано в User Service (временная версия)
- Возвращает нулевые модификаторы для всех пользователей
- Минимальный уровень персонажа (1)
- Отсутствие VIP бонусов и достижений
- Нулевые клановые бонусы

**Обоснование:** Для применения пользовательских модификаторов производству необходима информация о статусе, уровне и достижениях пользователя.

### Event Service (TBD - планируется в следующих версиях)

**Статус:** ⏳ Функционал отложен для будущих версий. В текущей реализации Production Service работает без интеграции с Event Service.

**Планируемые внутренние эндпоинты:**

#### Получение активных событийных модификаторов
```
GET /internal/events/active-production-modifiers
```

**Описание:** Возвращает активные событийные модификаторы для производства

**Выходные данные:**
```json
{
  "active_events": [
    {
      "event_id": "winter_festival_2025",
      "modifiers": {
        "crafting_speed_bonus": 0.25,
        "quality_bonus": 0.15
      },
      "valid_until": "2025-12-31T23:59:59Z"
    }
  ],
  "lunar_phase": {
    "phase": "full_moon",
    "crafting_chance_bonus": 0.05
  },
  "server_buffs": {
    "global_production_boost": 0.1
  }
}
```

**Обоснование:** Production Service будет учитывать временные события и модификаторы для корректного применения бонусов в будущих версиях.

### Inventory Service (доработка существующего)

**Статус:** ✅ Все необходимые внутренние эндпоинты уже реализованы согласно OpenAPI спецификации:
- `POST /inventory/reserve` - резервирование предметов
- `POST /inventory/return-reserve` - возврат резерва
- `POST /inventory/consume-reserve` - потребление резерва
- `POST /inventory/add-items` - добавление предметов

**Примечание:** Никаких доработок Inventory Service не требуется, все необходимые методы доступны.

